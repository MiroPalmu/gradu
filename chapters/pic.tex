\chapter{Particle-in-Cell}
To include kinetic effects in plasma simulations,
the method must be able to describe the evolution of the full distribution function.
With PIC, this is achieved by sampling the distribution function with macroparticles
and evolving them according to Maxwell’s equations.
The electromagnetic fields are represented on a grid through which the particles move,
giving rise to the name particle-in-cell.

The PIC scheme was formalised in 1970s
but has its roots in work by Buneman \cite{buneman_dissipation_1959}
and Dawson \cite{dawson_one-dimensional_1962} in the late 1950s.
Later, two classic PIC text books were published:
one by Hockney and Eastwood \cite{hockney_computer_1981} in 1981
and another by Birdsall and Langdon \cite{langdon_plasma_1991} in 1991,
the latter remains one of the most complete treatments of PIC to date.

Basic PIC consists of many smaller tasks, for which numerous algorithms exist with varying trade-offs.
A high-level overview of a single PIC time step is shown in Figure~\ref{fig:pic-scheme}.
In this chapter,
we describe the tasks illustrated in the figure in more detail
and discuss the set of algorithms implemented in the GPU port of Runko.

\input{chapters/pic-scheme}

\section{Physical model}\label{sec:pic-physical-model}

In relativistic PIC, the equations of motion for a particle
with three-velocity $\ve u$, coordinate velocity $\ve v(\ve u)$, mass $m$, and charge $q$
are~\cite{verboncoeur_particle_2005,vay_modeling_2014}:
\begin{align}
  \label{eq:newton-lorentz-vel}
  \frac{d\ve x}{dt} &= \ve v(\ve u) = \frac{\ve u}{\gamma}\,, \\
  \label{eq:newton-lorentz}
  m\frac{d\ve u}{dt} &= \ve F = q\left(\ve E + \frac{\ve v(\ve u)}{c} \times \ve B\right)\,,
\end{align}
where $\gamma = \sqrt{1 + \frac{\ve u^2}{c^2}}$ is the Lorentz factor,
and the force $\ve F$ is given by the Lorentz force.

Electric and magnetic fields, $\ve E$ and $\ve B$, are evolved according to
Maxwell's equations~\eqref{eq:maxwells}:
\begin{align}
  \label{eq:maxwell-faraday}
  \frac{\partial\ve B}{\partial t} &= -c \nabla\times\ve E\,, \\
  \label{eq:ampere-maxwell-law}
  \frac{\partial\ve E}{\partial t} &= c \nabla\times\ve B - 4\pi \ve J\,, \\
  \label{eq:gauss-law}
  \nabla\cdot\ve E &= 4\pi\rho\,, \\
  \label{eq:gauss-law-for-B}
  \nabla\cdot\ve B &= 0\,.
\end{align}
When charge conserving current deposition scheme is used
and the initial conditions satisfy Gauss's laws \eqref{eq:gauss-law} and \eqref{eq:gauss-law-for-B},
then they are automatically satisfied throughout the rest of the simulation as well.

\section{Field propagator}

The purpose of the field propagator is to evolve the electric field $\ve E$ and magnetic field $\ve B$
according to equations \eqref{eq:maxwell-faraday} and \eqref{eq:ampere-maxwell-law}.
This is typically achieved using finite-difference time-domain (FDTD)
discretizations on a Yee mesh~\cite{yee_numerical_1966}..
In this approach,
the electromagnetic fields are staggered in both time
and space to compute derivatives using centered finite differences,
as described in section~\ref{sec:finite-difference}.
In this section, we derive the second-order accurate FDTD
update equations for the electric and magnetic fields.

\subsection{Yee mesh\label{sec:yee-mesh}}

In a Yee mesh, the vertices are located at:
\begin{align}
  \label{eq:yee-vertex-locations}
  \ve x_{m,n,l}
  = m \Delta x_0 \hat{\ve e}_0 + n \Delta x_1\hat{\ve e}_1 + l \Delta x_2 \hat{\ve e}_2\,,
\end{align}
where $\Delta x_i$ is the grid spacing in the $\hat{\ve e}_i$ direction,
$\hat{\ve e}_i$ denotes the orthogonal unit vectors, and $m,n,l \in \mathbb{N}$.
Electric field components $E_i$ and current density componentes $J_i$
are stored at:
\begin{align}
  \label{eq:yee-E-locations}
  \ve x^{E_i}_{m,n,l} = \ve x_{m,n,l} + \frac{1}{2}\Delta x_i \hat{\ve e}_i =
  \begin{cases}
    \ve x_{m+\frac12, n, l} \quad & i=0\\
    \ve x_{m, n+\frac12, l} \quad & i=1 \\
    \ve x_{m, n, l+\frac12} \quad & i=2
  \end{cases}
\end{align}
and magnetic field components $B_i$ are stored at:
\begin{align}
  \label{eq:yee-B-locations}
  \ve x^{B_i}_{m,n,l} =
\ve x_{m,n,l} + \frac12 \sum_{r\in\{1, 2, 3\}/{i}}\Delta x_{i} \hat{\ve e}_{i} =
  \begin{cases}
    \ve x_{m, n+\frac12, l+\frac12} \quad & i=0\\
    \ve x_{m+\frac12, n, l+\frac12} \quad & i=1 \\
    \ve x_{m+\frac12, n+\frac12, l} \quad & i=2
  \end{cases}\,.
\end{align}
See Figure~\ref{fig:yee-mesh} for a schematic picture of the Yee mesh.

The most common way to solve equations~\eqref{eq:maxwell-faraday} and~\eqref{eq:ampere-maxwell-law}
numerically is the explicit leapfrog algorithm~\cite{verboncoeur_particle_2005,langdon_plasma_1991}.
In the leapfrog algorithm, in addition to spatial staggering, the fields are also staggered in time.
Electric fields and current densities are defined at times $s\Delta t$,
while magnetic fields are defined at times $\left(s + \frac12\right)\Delta t$,
where $s \in \mathbb{N}$ and $\Delta t$ is the length of one time step.
This time staggering creates a challenge for particle pushing,
which requires both fields at the same point in time.
To address this, the magnetic field is usually updated in two half-steps of $\frac12\Delta t$,
and particle pushing is performed between these updates.

Because the components of the electromagnetic fields are stored at different locations,
we can deduce the component solely from its position.
Thus, we adopt the following shorthand notation for the components
of $\ve E(t, \ve x)$ and $\ve B(t, \ve x)$:
\begin{align}
  \label{eq:shorthad-index-notation}
  \xi^{T}_{N,M,L} \equiv \xi\left(T\Delta t, \ve x^\xi_{N,M,L} \right)\,,
\end{align}
where $\xi$ denotes either $E$ or $B$.
For example $E^{s}_{n,m,l+\frac12}
= E_2\left(s\Delta t, \ve x^{E_2}_{n,m,l}\right)$
and $B^{s+\frac12}_{n+\frac12,m,l+\frac12}
= B_1\left(\left(s+\frac12 \right)\Delta t, \ve x^{B_1}_{n,m,l}\right)$.
With this notation, we can generally write the second-order accurate
centered finite-difference temporal and spatial derivatives \eqref{eq:centered-fd}.
For the temporal derivative, $h = \frac12 \Delta t$,
and for the spatial derivative, in the $\hat{\ve e}_i$ direction, $h = \frac12 \Delta x_i$.
Thus, we obtain:
\begin{align}
  \label{eq:yee-temporal-derivative}
  \Delta t\partial_t\xi^{T}_{N,M,L} &\approx \xi^{T+\frac12}_{N,M,L} - \xi^{T-\frac12}_{N,M,L}\,,\\
  \label{eq:yee-spatial-derivative}
  \begin{bmatrix}
    \Delta x_0 \partial_{x_0} \\
    \Delta x_1 \partial_{x_1} \\
    \Delta x_2 \partial_{x_2}
  \end{bmatrix}
  \xi^{T}_{N,M,L} &\approx
  \begin{bmatrix}
    \xi^{T}_{N+\frac12,M,L} - \xi^{T}_{N-\frac12,M,L} \\
    \xi^{T}_{N,M+\frac12,L} - \xi^{T}_{N,M-\frac12,L} \\
    \xi^{T}_{N,M,L+\frac12} - \xi^{T}_{N,M,L-\frac12}
  \end{bmatrix}\,.
\end{align}

Note that in the next subsection we will evaluate derivatives $\partial_{\mu}\xi$
at specific locations where, on the Yee mesh,the field $\xi$ may not be directly defined.
However, we will use centered finite differences for these derivatives,
and it turns out that we only require field components
at positions where the Yee mesh provides exactly the components we need.

\subsection{Finite-difference time domain}

We now apply the finite-difference derivatives~\eqref{eq:yee-temporal-derivative}
and~\eqref{eq:yee-spatial-derivative} to the dynamical Maxwell equations~\eqref{eq:maxwell-faraday}
and~\eqref{eq:ampere-maxwell-law} in order to derive rules for updating the fields in time.
Ignoring the current density for the moment\footnote{We can always add the current to the electric field,
  as they are stored at the same location and time in the Yee mesh.},
both equations can be written in a form that, at time $T\Delta t$ and position $\ve x_{N,M,L}$ becomes:
\begin{align}
  \partial_t
  \begin{bmatrix}
    \alpha^T_{N,M,L} \\ \beta^T_{N,M,L} \\ \gamma^T_{N,M,L}
  \end{bmatrix}
  = \pm c \nabla \times
  \begin{bmatrix}
    \mu^T_{N,M,L} \\ \nu^T_{N,M,L} \\ \rho^T_{N,M,L}
  \end{bmatrix}
  = \pm c
  \begin{bmatrix}
    \partial_{x_1}\rho^T_{N,M,L} - \partial_{x_2}\nu^T_{N,M,L} \\
    \partial_{x_2}\mu^T_{N,M,L} - \partial_{x_0}\rho^T_{N,M,L} \\
    \partial_{x_0}\nu^T_{N,M,L} - \partial_{x_1}\mu^T_{N,M,L}
  \end{bmatrix}\,.
\end{align}
Now we apply the second-order accurate centered finite-difference
derivatives~\eqref{eq:yee-temporal-derivative} and~\eqref{eq:yee-spatial-derivative}
on the Yee mesh to obtain the update equations:
\begin{equation}
  \label{eq:fdtd2-generic-update}
  \begin{split} 
  \begin{bmatrix}
    \alpha^{T+\frac12}_{N,M,L} \\ \beta^{T+\frac12}_{N,M,L} \\ \gamma^{T+\frac12}_{N,M,L}
  \end{bmatrix}
  & \approx
  \begin{bmatrix}
    \alpha^{T-\frac12}_{N,M,L} \\ \beta^{T-\frac12}_{N,M,L} \\ \gamma^{T-\frac12}_{N,M,L}
  \end{bmatrix} \\
  & \pm
  \begin{bmatrix}
    \hat{c}_1\left(\rho^T_{N,M+\frac12,L} - \rho^T_{N,M-\frac12,L}\right)
    - \hat{c}_2\left(\nu^T_{N,M,L+\frac12} - \nu^T_{N,M,L-\frac12}\right) \\
    \hat{c}_2\left(\mu^T_{N,M,L+\frac12} - \mu^T_{N,M,L-\frac12}\right)
    - \hat{c}_0\left(\rho^T_{N+\frac12,M,L} - \rho^T_{N-\frac12,M,L}\right) \\
    \hat{c}_0\left(\nu^T_{N+\frac12,M,L} - \nu^T_{N-\frac12,M,L}\right)
    - \hat{c}_1\left(\mu^T_{N,M+\frac12,L} - \mu^T_{N,M-\frac12,L}\right)
  \end{bmatrix}\,,
  \end{split}
\end{equation}
where we have used the one-dimensional Courant numbers for different directions,
defined as $\hat{c}_i\equiv \frac{c\Delta t}{\Delta x_i}$.

Now we can extract the actual update equations for $\ve E$ and $\ve B$
from equation~\eqref{eq:fdtd2-generic-update}
by evaluating their components at specific locations in time and space. First, we substitute:
\begin{align}
  \begin{bmatrix}
    \alpha \\ \beta \\ \gamma
  \end{bmatrix}
  = \ve B
  \quad
  \begin{bmatrix}
    \mu \\ \nu \\ \rho
  \end{bmatrix}
  = \ve E \quad
  (T, N, M, L) =
  \begin{cases}
    (s, n, m+\frac12, l+\frac12) \quad & \text{on row 0} \\
    (s, n+\frac12, m, l+\frac12) \quad & \text{on row 1} \\
    (s, n+\frac12, m+\frac12, l) \quad & \text{on row 2}
  \end{cases}
\end{align}
and obtain:
\begin{equation}
\label{eq:fdtd2-B-update}
\begin{split}
  \begin{bmatrix}
    B^{s+\frac12}_{n,m+\frac12,l+\frac12} \\
    B^{s+\frac12}_{n+\frac12,m,l+\frac12} \\
    B^{s+\frac12}_{n+\frac12,m+\frac12,l}
  \end{bmatrix}
  & \approx
  \begin{bmatrix}
    B^{s-\frac12}_{n,m+\frac12,l+\frac12} \\
    B^{s-\frac12}_{n+\frac12,m,l+\frac12} \\
    B^{s-\frac12}_{n+\frac12,m+\frac12,l}
  \end{bmatrix}\\
  & -
  \begin{bmatrix}
    \hat{c}_{1}\left(E^{s}_{n,m+1,l+\frac12} - E^{s}_{n,m,l+\frac12}\right)
    - \hat{c}_{2}\left(E^{s}_{n,m+\frac12,l+1} - E^{s}_{n,m+\frac12,l}\right) \\
    \hat{c}_{2}\left(E^{s}_{n+\frac12,m,l+1} - E^{s}_{n+\frac12,m,l}\right)
    - \hat{c}_{0}\left(E^{s}_{n+1,m,l+\frac12} - E^{s}_{n,m,l+\frac12}\right) \\
    \hat{c}_{0}\left(E^{s}_{n+1,m+\frac12,l} - E^{s}_{n,m+\frac12,l}\right)
    - \hat{c}_{1}\left(E^{s}_{n+\frac12,m+1,l} - E^{s}_{n+\frac12,m,l}\right)
  \end{bmatrix}
\end{split}
\end{equation}
and second, we substitute:
\begin{align}
  \begin{bmatrix}
    \alpha \\ \beta \\ \gamma
  \end{bmatrix}
  = \ve E
  \quad
  \begin{bmatrix}
    \mu \\ \nu \\ \rho
  \end{bmatrix}
  = \ve B \quad
  (T, N, M, L) =
  \begin{cases}
    (s+\frac12, n+\frac12, m, l) \quad & \text{on row 0} \\
    (s+\frac12, n, m+\frac12, l) \quad & \text{on row 1} \\
    (s+\frac12, n, m, l+\frac12) \quad & \text{on row 2}
  \end{cases}
\end{align}
and obtain (with the current density added back in):
\begin{equation}
\label{eq:fdtd2-E-update}
\begin{split}
  \begin{bmatrix}
    E^{s+1}_{n+\frac12,m,l} \\ E^{s+1}_{n,m+\frac12,l} \\ E^{s+1}_{n,m,l+\frac12}
  \end{bmatrix}
  & \approx
  \begin{bmatrix}
    E^{s}_{n+\frac12,m,l} \\ E^{s}_{n,m+\frac12,l} \\ E^{s}_{n,m,l+\frac12}
  \end{bmatrix}
  + 4\pi\Delta t
  \begin{bmatrix}
    J^{s}_{n+\frac12,m,l} \\ J^{s}_{n,m+\frac12,l} \\ J^{s}_{n,m,l+\frac12}
  \end{bmatrix} \\
  & +
  \begin{bmatrix}
    \hat{c}_1\left(B^{s+\frac12}_{n+\frac12,m+\frac12,l} - B^{s+\frac12}_{n+\frac12,m-\frac12,l}\right)
    - \hat{c}_2\left(B^{s+\frac12}_{n+\frac12,m,l+\frac12} - B^{s+\frac12}_{n+\frac12,m,l-\frac12}\right) \\
    \hat{c}_2\left(B^{s+\frac12}_{n,m+\frac12,l+\frac12} - B^{s+\frac12}_{n,m+\frac12,l-\frac12}\right)
    - \hat{c}_0\left(B^{s+\frac12}_{n+\frac12,m+\frac12,l} - B^{s+\frac12}_{n-\frac12,m+\frac12,l}\right) \\
    \hat{c}_0\left(B^{s+\frac12}_{n+\frac12,m,l+\frac12} - B^{s+\frac12}_{n-\frac12,m,l+\frac12}\right)
    - \hat{c}_1\left(B^{s+\frac12}_{n,m+\frac12,l+\frac12} - B^{s+\frac12}_{n,m-\frac12,l+\frac12}\right)
  \end{bmatrix}\,.
\end{split}
\end{equation}

As noted at the end of subsection \ref{sec:yee-mesh} on the Yee mesh,
the update equations \eqref{eq:fdtd2-B-update} and \eqref{eq:fdtd2-E-update}
do not require any values that are not already present on the Yee mesh.

\input{chapters/yee-mesh}

\section{Field interpolator}\label{sec:field-interpolator}

Before a particle can be pushed, the electromagnetic fields on the discrete Yee mesh
must be interpolated to the continuous particle positions.
Various interpolation schemes exists,offering different levels of accuracy and computational cost.
The GPU port of Runko uses linear interpolation.

The interpolation is performed for the fields $\ve E$ and $\ve B$, which are located
on the Yee mesh according to~\eqref{eq:yee-E-locations} and \eqref{eq:yee-B-locations}.
Wile interpolation could be done directly from those locations to the particle locations,
it is common practice to first compute $\ve E$ and $\ve B$
at the Yee mesh vertex locations~\eqref{eq:yee-vertex-locations},
for example via simple spatial averaging.
This approach simplifies the definition and implementation of interpolators
and helps reduce short-wavelength noise~\cite{langdon_plasma_1991}.

We can now express the interpolation of a generic function $f$,
defined on the grid vertices~\eqref{eq:yee-vertex-locations},
to an arbitrary point $\ve x$:
\begin{align}
  f(\ve x) =
  \Delta V \sum_{n,m,l} f_{n,m,l} S'\left(\ve x_{n, m, l}, \ve x\right)\,,
\end{align}
where $\Delta V = \prod_i \Delta x_i$, $f_{n,m,l} \equiv f(\ve x_{n,m,l})$, and
and $S'$ is the weighting function, normalized such that at every position\footnote{
  This normalization follows the convention used in~\cite{langdon_plasma_1991},
  ensuring that the grid contains the same total charge as the particles:
  \begin{align}
  \int_V \rho dV \approx
  \Delta V\sum_{n,m,l}\rho_{n,m,l} =
  \Delta V\sum_{n,m,l}\sum_j q_j S'(\ve x_{n,m,l}, \ve x_j) = \sum_j q_j\,,
  \end{align}
  where the sum over $j$ runs over all particles, and $\ve x_j$ denotes the particle positions.
}:
\begin{align}
  \Delta V \sum_{n,m,l}S' \left(\ve x_{n, m, l}, \ve x\right) = 1\,.
\end{align}
The choice of the shape function $S'$ determines the interpolation scheme.
Typically, the interpolation is performed independently in each spatial direction.
In such cases:
\begin{align}
  S'(\ve X, \ve x) = S(X_0 - x_0)S(X_1 - x_1)S(X_2 - x_2)\,.
\end{align}

B-splines are commonly used as the weighing functions $S(x)$.
Starting from the zeroth-order B-spline, one can construct B-splines with arbitrary high order,
although typically only the lowest-order splines are used.
The first four are shown in Figure~\ref{fig:spline-plot}.
Choosing the zeroth order B-spline is equivalent to using the value from the nearest grid point,
while choosing the first-order B-spline corresponds to linear interpolation.

\begin{figure}[h]
  \centering
  \includegraphics{chapters/spline.pdf}
  \caption{Zeroth-, first-, second-, and third-order B-spline weighing functions $S$.
    Higher-order B-splines produce smoother interpolation.
  }
  \label{fig:spline-plot}
\end{figure}

\section{Particle pusher}

The positions and velocities of particles are updated according to equations
equations~\eqref{eq:newton-lorentz-vel} and~\eqref{eq:newton-lorentz}.
This procedure is called particle pushing,
and the numerical methods used for it are referred to as particle pushers.
Similar to the field updates, particle pushers often employ the leapfrog scheme,
so particle positions are stored at times $s\Delta t$ and velocities at
times $\left(s+\frac12\right)\Delta t$.
Applying the second-order accurate centered finite-difference~\eqref{eq:centered-fd}
to equations~\eqref{eq:newton-lorentz} and~\eqref{eq:newton-lorentz-vel}
with $h=\frac12 \Delta t$, we can solve for the update equations:
\begin{align}
  \label{eq:particle-update-pos}
  \ve x^{s+1} &= \ve x^{s} + \Delta t \ve v(\ve u^{s+\frac12})\,, \\
  \label{eq:particle-update-vel}
  \ve u^{s+\frac12} &= \ve u^{s-\frac12}
                      + \Delta t\frac{q}{m}\left(\ve E^s + \bar{\ve v}^s\times\ve B^s\right)\,,
\end{align}
where the superscripts denote the time step, similar to equation~\eqref{eq:shorthad-index-notation},
and $\bar{\ve v}^s$ represents some average for coordinate velocity at times $s\Delta t$.
To close the system, this average must be expressed as a function of the other quantaties.

There are multiple different options for calculating $\bar{\ve v}^s$
corresponding to the different particle pushers.
The common challenge is that the expressions often involve $\ve u^{s+\frac12}$,
which appears to make the update equation~\eqref{eq:particle-update-vel} implicit.
However, various pushers have procedures that allow solving~\eqref{eq:particle-update-vel}
in steps, keeping the method explicit.

In this section, we compare properties of the Boris pusher (1960)~\cite{boris_relativistic_1960},
Vay's method (2008)~\cite{vay_simulation_2008}, and
Higuera-Cary method (2017)~\cite{higuera_structure-preserving_2017}.
Since the GPU port of Runko uses the Boris pusher, we will examine it in more detail.

\subsection{Properties}

We begin by listing the choises for $\bar{\ve v}^s$.
The Boris pusher uses:
\begin{align}
  \label{eq:boris-avg-vel}
  \bar{\ve v}^s_b \equiv \frac{\ve v(u^{s+\frac12} - \boldsymbol{\epsilon}^{s+\frac12})
  + \ve v(u^{s-\frac12} + \boldsymbol{\epsilon}^{s-\frac12}}{2\gamma^s}\,,
\end{align}
where $\boldsymbol{\epsilon}^s = \frac{q\Delta t\ve E^s}{2m}$
is the change of coordinate velocity due to the electric field in half a time step.
It is assumed that the vectors $u^{s\pm\frac12} \mp \boldsymbol{\epsilon}^{s\pm\frac12}$
share the same length.
Vay's method uses:
\begin{align}
  \bar{\ve v}^s_v \equiv
  \frac{ \ve v^{s-\frac12}  + \ve v^{s+\frac12}}{2}
\end{align}
and, Higuera-Cary method uses:
\begin{align}
  \bar{\ve v}^s_{hc} \equiv \ve v \left( \frac{\ve u^{s-\frac12} + \ve u^{s+\frac12}}{2} \right)\,.
\end{align}

The choices for $\bar{\ve v}^s$ appear very similar;
however, the methods possess distinct properties that are crucial for physical accuracy.
Since the underlying physical system is Hamiltonian,
the solutions lie on a symplectic manifold in phase space~\cite{goldstein_classical_2014}.
Symplectic integrators are those whose solutions remain on this symplectic manifold.
The Kolmogorov–Arnold–Moser theorem guarantees that their long-term evolution
preserves physical accuracy\footnote{
  Defining what a symplectic manifold is
  and what constitutes a physically accurate long-term evolution of a Hamiltonian system
  lies outside the scope of this thesis.
}.
Unfortunately, no explicit symplectic integrator is currently known for charged-particle motion
in arbitrary electromagnetic fields~\cite{higuera_structure-preserving_2017}.
Nevertheless, integrators can be designed to be phase-space volume-preserving,
which prevents the emergence of attractors and repellers in the integrated system.

The Boris pusher is volume-preserving, whereas Vay’s method is not.
Conversely, Vay’s method computes the $\ve E \times \ve B$ drift correctly,
while the Boris pusher does not.
The Higuera–Cary method, on the other hand, possesses both of these properties.
A common feature among all three methods is that
they conserve energy in the absence of an electric field and are second-order accurate in time.
From a computational perspective, the Boris pusher is the fastest,
whereas Vay’s and Higuera–Cary methods exhibit similar computational const.

\subsection{Boris pusher}

We begin by substituting~\eqref{eq:boris-avg-vel} into~\eqref{eq:particle-update-vel}
and adopting a notation in which
we drop the superscript $s$ and replace superscripts
$s+\frac12$ with $f$ and $s-\frac12$ with $i$:
\begin{align}
  \label{eq:boris-derivation-1}
  \ve u^f - \ve u^i
  %&= \frac{q\Delta t}{m}\left(\ve E + \frac{\ve u^f + \ve u^i}{2c\gamma}\times\ve B\right) \\
  &= 2\boldsymbol{\epsilon} + \eta(\ve u^f + \ve u^i) \times \hat{\ve B}\,,
\end{align}
where we define $\boldsymbol{\epsilon} = \frac{q\Delta t\ve E}{2m}$,
$\eta = \frac{q\Delta t B}{2mv\gamma}$ and the unit vector $\hat{\ve B} = \ve BB^{-1}$.
Note that the same Lorentz factor is shared between $u^f$ and $u^i$
because we assume they have the same length.
We want to find a way to evaluate~\eqref{eq:boris-derivation-1}
without using implicit methods; that is,
we seek to evaluate the right-hand side without explicitly requiring $\ve u^f$.

We define the vectors $\ve u_+ = \ve u^f - \boldsymbol{\epsilon}$
and $\ve u_- = \ve u^i + \boldsymbol{\epsilon}$,
thus equation \eqref{eq:boris-derivation-1} can be rewritten as:
\begin{align}
  \label{eq:dirty-fix}
  \ve u_+ - \ve u_- &= \eta(\ve u_+ + \ve u_-) \times \hat{\ve B}\,.
\end{align}
We note that the above equation~\eqref{eq:dirty-fix} contains no components along $\hat{\ve B}$.
Denoting vector components in the plane perpendicular to $\hat{\ve B}$ with a prime,
we can write:
\begin{align}
  \label{eq:boris-derivation-2}
  \ve u_+ - \ve u_- = \ve u'_+ - \ve u'_- &= \eta(\ve u'_+ + \ve u'_-) \times \hat{\ve B}\,.
\end{align}
We can deduce that the vectors $\ve u'_+ - \ve u'_-$ and $\ve u'_+ + \ve u'_-$
are perpendicular to each other.
By taking the dot product of the equation~\eqref{eq:boris-derivation-2} with $\ve u'_+ + \ve u'_-$
we find that $u'_+ = u'_-$.
Let $\theta$ denote the angle between the vectors $\ve u'_+$ and $\ve u'_-$.
A diagram illustrating these vectors is shown in Figure~\ref{fig:boris},
where we have added helper vectors $\ve h$, $\ve L_0$, $\ve L_1$ and $\ve u'_- \times \ve b$,
such that $\ve L_0$ and $\ve L_1$ are perpendicular to each other,
$\ve b = b \hat{\ve B}$,
and that $\ve L_0 + \ve L_1 = \ve u'_- + \ve u'_- \times \ve b$.
Using these definitions we note that $b = \tan\frac{\theta}{2} = \frac{h}{L_1}$
and $L_0 = L_1 b^2$.

\input{chapters/boris}

We now attempt to express $\ve u'_+ - \ve u'_-$
in a different form than in~\eqref{eq:boris-derivation-2}.
Specifically, we can write:
\begin{equation}
\begin{split}
  \ve u'_+ - \ve u'_- &= 2h \hat{\ve L}_1 \times \hat{\ve B}
  = \frac{2}{1+b^2}(\ve L_0 + \ve L_1) \times \ve b \\
  &= \frac{2}{1+b^2}(\ve u'_- + \ve u'_- \times \ve b)\times \ve b\,,
\end{split}
\end{equation}
where $\hat{\ve L}_1$ is the unit vector along $\ve L_1$.
We now return to $\ve u^f$ and $\ve u^i$ to obtain the Boris pusher update equation:
\begin{equation}
\begin{split}
  \ve u^f &= \ve u^i + 2 \boldsymbol{\epsilon}
            + \frac{2}{1+b^2}(\ve u'_- + \ve u'_- \times \ve b)\times \ve b \\
          &= \ve u^i + \frac{q\Delta t \ve E}{m}
            + \frac{2}{1+b^2}\left(\ve u^i + \frac{q\Delta t \ve E}{2m}
            + \left(\ve u^i + \frac{q\Delta t \ve E}{2m}\right) \times \ve b\right)\times \ve b\,.
\end{split}
\end{equation}
The only remaining step is to determine the angle $\theta$ between $\ve u_+$ and $\ve u_-$
in order to calculate $\ve b$. To do this, we use physical argument:
the angle should correspond to the gyrotation induced by the magnetic field.
Thus, using the cyclotron frequency from~\eqref{eq:cyclotron-frequency}:
\begin{align}
  \theta \approx \Delta t \omega_B = \frac{qB\Delta t}{mc\gamma}\,.
\end{align}
Under the assumption of a sufficiently small time step:
\begin{align}
  b  = \tan\frac\theta 2 = \frac\theta 2 + O(\Delta t^3)
  = \frac{qB\Delta t}{2mc\gamma} + O(\Delta t^3)\,.
\end{align}

\section{Current deposition}
The moving particles generate a current according to equation~\eqref{eq:current-density},
which is deposited onto the Yee mesh.
As stated in section ~\ref{sec:pic-physical-model},
if this deposition is charge-conserving and equations~\eqref{eq:gauss-law} and~\eqref{eq:gauss-law-for-B}
are satisfied initially,
then they remain satisfied at all later times.
For example, similar to the approach in section~\ref{sec:field-interpolator},
we could interpolate particle velocities to neighboring grid locations.
However, this scheme is not charge
conserving~\cite{hockney_computer_1981,langdon_plasma_1991,blinne_new_2003}.
For a current deposition method to be charge-conserving,
it must satisfy the continuity equation for charge density,
which is derived by taking the time derivative of Gauss’s law~\eqref{eq:gauss-law}:
\begin{align}
  \label{eq:current-density-continuation}
  \frac{\partial \rho}{\partial t} + \nabla \cdot \ve J = 0\,.
\end{align}

Several charge-conserving current deposition schemes exist.
The GPU port of Runko implements the so-called ZigZag method,
as described in~\cite{blinne_new_2003},
so this section focuses on that method and the Villasenor–Buneman method~\cite{villasenor_rigorous_1992},
since the ZigZag method can be considered an optimized version of the latter.
Another notable scheme is the density decomposition method proposed by
Esirkepov~\cite{esirkepov_exact_2001}.
A general treatment of charge-conserving methods using finite-element techniques is provided by
Eastwood in~\cite{eastwood_virtual_1991},
with an extension to curvilinear coordinates in~\cite{eastwood_body-fitted_1995}.
Both the Villasenor–Buneman method and Esirkepov’s density decomposition
can be regarded as special cases of Eastwood’s scheme.

The Villasenor–Buneman method can only be applied if the particle trajectory during one time step
remains within the same Yee mesh cell (see Figure~\ref{fig:yee-mesh}).
If it does not, the movement is split into multiple shorter segments,
each confined to a single cell.
The difference between the Villasenor–Buneman method and the ZigZag method
lies in how this splitting is performed.
In the Villasenor–Buneman method,
the particle’s motion within one time step is assumed to be straight and is split
at the Yee mesh cell faces.
In contrast, the ZigZag method assumes the motion occurs via a so-called relay point.
The advantage of the relay point is that,
regardless of particle position and velocity,
the current deposition is calculated in a uniform manner,
whereas the Villasenor–Buneman method requires conditional checks
to determine whether the particle crosses zero, one, or two cell faces.

We note that the 3D ZigZag method described in the original paper
appears to be defective and not truly charge-conserving.
For particle motion confined to a single cell,
the method adds current in the same way as the Villasenor–Buneman method
(equations (35–37) in~\cite{villasenor_rigorous_1992}),
but it omits the term proportional to $\delta x_0 \delta x_1 \delta x_2$,
where $\delta x_i$ represents the change in the particle’s position during one time step.
As a result, only diagonal trajectories are affected.
This observation is consistent with the findings reported in~\cite{steiniger_ez:_2023}.
Preliminary tests indicate that the 3D ZigZag method can be corrected by adding the missing terms,
but this subject requires further studies.

\subsection{Villasenor-Buneman method}

The Villasenor–Buneman method assumes that particles contribute current to the Yee mesh
as an axis-aligned box with a uniform charge distribution, equal in size to one Yee mesh cell.
Therefore, the particle’s effective charge density is
$\rho_q = \frac{q}{\Delta x_0\Delta x_1\Delta x_2}$.
Charge is conserved on each cell of a discrete grid that has the same size as the Yee mesh
but is staggered by half a grid spacing in each direction.
When a particle moves inside a single Yee mesh cell,
it generates current through exactly eight faces of this staggered grid.
These eight faces, along with the Yee mesh cell,
are shown in Figure~\ref{fig:yee-mesh-current-deposition}.
The currents through each face can be integrated so that
the total current into a single cell during one time step equals the change in charge within that cell.
Thus, the continuity equation for charge density~\eqref{eq:current-density-continuation}
is satisfied when integrated over a single cell.

\input{chapters/yee-mesh-current-deposition}

Let the particle positions $\ve x^s$ and $\ve x^{s+1}$ lie within the same cell,
which is spanned between $\ve x_{m,n,l}$ and $\ve x_{m+1,n+1,l+1}$.
Define:
\begin{align}
  \delta \ve x &\equiv \ve x^{s+1} - \ve x^{s} \\
  r^s_i &\equiv \left(\ve x^s - \ve x_{m,n,l}\right)_1
\end{align}
and let:
\begin{align}
  \bar{\ve r} \equiv \frac{\ve r^{s+1} + \ve r^s}2\,.
\end{align}
denote the midpoint in local coordinates inside the cell.
Assuming that the particle with charge $q$ moves at constant velocity during one time step,
its trajectory can be written as
\begin{align}
  \ve r(t) = \bar{\ve r} + t\delta \ve x\,,\quad t \in \left[-\frac12, \frac12\right]\,.
\end{align}
Then, the integrals for the total currents in $\hat{\ve e}_0$ direction
at $\ve x^{E_0}_{m,n+1,l+1}$ can be expressed as:
\begin{equation}
  \label{eq:total-current-flux-1}
\begin{split}
  J_{m+\frac12, n + 1, l + 1}\Delta x_1 \Delta x_2 &= \rho_q\int_{r^s_0}^{r^{s+1}_0} r_1(t)r_2(t)dr_0 \\
    &= \rho_q\int_{-\frac12}^{\frac12} \left(\bar{r}_1 + t\delta x_1\right)
                             \left(\bar{r}_2 + t\delta x_2\right)\delta x_0dt \\
    &= \rho_q\delta x_0\bar{r}_1\bar{r}_2 + \frac{\delta x_0 \delta x_1 \delta x_2}{12}\,,
\end{split}
\end{equation}
where we use the notation from the Yee mesh subsection~\ref{sec:yee-mesh} for the current density.
Similarly, for the three other faces:
\begin{equation}
\begin{split}
  \label{eq:total-current-flux-2}
  J_{m+\frac12, n, l}\Delta x_1 \Delta x_2
  &= \rho_q\int_{r^s_0}^{r^{s+1}_0} (1 - r_1(t))(1 - r_2(t))dr_0 \\
  &= \rho_q\delta x_0(1 - \bar{r}_1)(1 - \bar{r}_2) + \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,,\\
  J_{m+\frac12, n, l+1}\Delta x_1 \Delta x_2
  &= \rho_q\int_{r^s_0}^{r^{s+1}_0} (1 - r_1(t))r_2(t)dr_0 \\
  &= \rho_q\delta x_0(1 - \bar{r}_1)\bar{r}_2 - \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,, \\
  J_{m+\frac12, n+1, l}\Delta x_1 \Delta x_2
  &= \rho_q\int_{r^s_0}^{r^{s+1}_0} r_1(t)(1-r_2(t))dr_0 \\
  &= \rho_q\delta x_0\bar{r}_1(1-\bar{r}_2) - \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,.
\end{split}
\end{equation}
Contributions to the other components can be obtained from equations~\eqref{eq:total-current-flux-1}
and~\eqref{eq:total-current-flux-2} by cclic permutation of the indices.
For the components in the $\hat{\ve e}_1$:
\begin{equation}
\begin{split}
  \label{eq:total-current-flux-3}
  J_{m+1, n +\frac12, l + 1}\Delta x_0 \Delta x_2
  &= \rho_q\delta x_1\bar{r}_0\bar{r}_2 + \rho_q\frac{\delta x_0 \delta x_1 \delta x_2}{12}\,, \\
  J_{m, n+\frac12, l}\Delta x_0 \Delta x_2
  &= \rho_q\delta x_1(1 - \bar{r}_0)(1 - \bar{r}_2) + \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,,\\
  J_{m+1, n+\frac12, l}\Delta x_0 \Delta x_2
  &= \rho_q\delta x_1\bar{r}_0(1-\bar{r}_2) - \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,, \\
  J_{m, n+\frac12, l+1}\Delta x_0 \Delta x_2
  &= \rho_q\delta x_1(1 - \bar{r}_0)\bar{r}_2 - \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}
\end{split}
\end{equation}
and for the components in the $\hat{\ve e}_2$ direction:
\begin{equation}
\begin{split}
  \label{eq:total-current-flux-4}
  J_{m+1, n +1, l +\frac12}\Delta x_0 \Delta x_1
  &= \rho_q\delta x_2\bar{r}_0\bar{r}_1 + \rho_q\frac{\delta x_0 \delta x_1 \delta x_2}{12}\,, \\
  J_{m, n, l+\frac12}\Delta x_0 \Delta x_1
  &= \rho_q\delta x_2(1 - \bar{r}_0)(1 - \bar{r}_1) + \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,,\\
  J_{m, n+1, l+\frac12}\Delta x_0 \Delta x_1
  &= \rho_q\delta x_2(1 - \bar{r}_0)\bar{r}_1 - \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,, \\
  J_{m+1, n, l+\frac12}\Delta x_0 \Delta x_1
  &= \rho_q\delta x_2\bar{r}_0(1-\bar{r}_1) - \rho_q\frac{\delta x_0\delta x_1\delta x_2}{12}\,.
\end{split}
\end{equation}
A scheme of what is integrated is shown in Figure~\ref{fig:vb-integrals}.

\input{chapters/yee-mesh-current-deposition-old}

To verify that the scheme is charge-conserving,
we calculate the total change in charge within the volume spanned from $\ve x_{m+1,n+1,l+1}$ to
$\ve x_{m+2,n+2,l+2}$ during one time step:
\begin{equation}
\begin{split}
  \Delta q &=
  J_{m+\frac12, n+1, l+1} \Delta x_1\Delta x_2 +
  J_{m+1, n+\frac12, l+1} \Delta x_0\Delta x_2 +
               J_{m+1, n+1, l+\frac12} \Delta x_0\Delta x_1 \\
  &= \rho_q\left(r^{s+1}_0r^{s+1}_1r^{s+1}_2 - r^{s}_0r^{s}_1r^{s}_2\right)\,.
\end{split}
\end{equation}
This is precicesly the difference between the particle's charge contribution
into the cell before and after the move.
A similar check can be performed for the other cells as well.
We note that, due to the linearity of the current continuity equation,
this check for a single particle is sufficient to confirm that the entire method is charge conserving.

\subsection{ZigZag method}

As stated earlier, in order to apply the Villasenor–Buneman method,
the particle trajectory must be split into sub-trajectories, each confined to a single Yee mesh cell.
In the ZigZag method, these sub-trajectories pass through a relay point.
Assuming that the particle position $\ve x^s$ lies in the cell spanned between
$\ve x_{a_0,a_1,a_2}$ and $\ve x_{a_0+1,a_1+1,a_2+1}$,
and the position $\ve x^{s+1}$ lies in the cell spanned between
$\ve x_{b_0,b_1,b_2}$ and $\ve x_{b_0+1,b_1+1,b_2+1}$,
then the relay point $\ve R$ is defined as:
\begin{equation}
  R_i =
  \begin{cases}
    \frac{x^{s}_i+x^{s+1}_i}{2} \quad & \text{for } a_i = b_i \\
    \Delta x_i\max(a_i, b_i) \quad & \text{for } a_i \neq b_i\,.
  \end{cases}
\end{equation}
Figure~\ref{fig:zigzags} illustrates the four different types of movements involving the relay point.

\input{chapters/path-splitting}

The benefit of splitting the trajectory in this manner is that the relay point coordinates
can be computed without conditionals by using the algorithm described in~\cite{blinne_new_2003}:
\begin{align}
  R_i = \Delta x_i \min\left[
  \min(a_i, b_i) + 1, \max\left\{\max(a_i, b_i), \frac{x^{s}_i+x^{s+1}_i}{2}\right\}
  \right]\,.
\end{align}
After the relay point has been determined,
the Villasenor–Buneman method can be applied to both subtrajectories.
Compared to the original scheme described in~\cite{villasenor_rigorous_1992},
the conditionless ZigZag achieves superior performance.


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../gradu"
%%% End:
