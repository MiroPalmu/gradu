\chapter{Particle-in-Cell}

For plasma simulation to include kinetic effects, it somehow has to be able to describe
evolution of the full distributions function. In PIC this is achieved by sampling
it with macroparticles then evolving them based on Maxwell's equations.
The electromagnetic fields are represented on a grid in which the particles move,
thus giving the name particle-in-cell.
PIC scheme was formalised in 1970s but has roots in work done by Buneman \cite{buneman_dissipation_1959}
and Dawson \cite{dawson_one-dimensional_1962} in the late 1950s.
Later two classic PIC text books were published
by Hockney and Eastwood \cite{hockney_computer_1981} in 1981
and by Birdsall and Langdon \cite{langdon_plasma_1991} in 1991
from which the latter remains one of the most complete treatments of the PIC overall.

Basic PIC consists of many smaller tasks
for which there exists numerous algorithms with differing trade-offs.
High-level overview of a one PIC time step is given in figure \ref{fig:pic-scheme}.
In this chapter we will describe the tasks seen in the figure in more detail and go through
a set of algorithms implemented in the GPU port of Runko.

\input{chapters/pic-scheme}

\section{Overview of underlying physics}

In relativistic PIC the equations of motion for a particle
with three-velocity $\ve u$, coordinate velocity $\ve v(\ve u)$, mass $m$ and charge $q$
are~\cite{verboncoeur_particle_2005,vay_modeling_2014}:
\begin{align}
  \label{eq:newton-lorentz-vel}
  \frac{d\ve x}{dt} &= \ve v(\ve u) = \frac{\ve u}{\gamma} \\
  \label{eq:newton-lorentz}
  m\frac{d\ve u}{dt} &= \ve F = q\left(\ve E + \frac{\ve v(\ve u)}{c} \times \ve B\right)
\end{align}
where $\gamma = \sqrt{1 + \frac{\ve u^2}{c^2}}$ is the Lorentz factor
and the force $\ve F$ is given by the Lorentz force.

Electric and magnetic fields $\ve E$ and $\ve B$ are evolved according to the Maxwell's equations
\eqref{eq:maxwells}:
\begin{align}
  \label{eq:maxwell-faraday}
  \frac{\partial\ve B}{\partial t} &= -c \nabla\times\ve E \\
  \label{eq:ampere-maxwell-law}
  \frac{\partial\ve E}{\partial t} &= c \nabla\times\ve B - 4\pi \ve J \\
  \label{eq:gauss-law}
  \nabla\cdot\ve E &= 4\pi\rho \\
  \label{eq:gauss-law-for-B}
  \nabla\cdot\ve B &= 0
\end{align}
When charge conserving current deposition scheme is used
and the initial conditions fulfill Gauss's laws \eqref{eq:gauss-law} and \eqref{eq:gauss-law-for-B}
then they are automatically fulfilled the rest of the simulation of as well.

\section{Field propagator}

Purpose of the field propagator is to evolve electric field $\ve E$ and magnetic field $\ve B$
according to equations \eqref{eq:maxwell-faraday} and \eqref{eq:ampere-maxwell-law}.
Typically this is achieved with finite-difference time domain (FDTD)
discretizations on a Yee mesh \cite{yee_numerical_1966}.
This means that the electromagnetic fields are staggered in time and space
in order to calculate derivatives using centered finite-difference
seen in the section~\ref{sec:finite-difference}.
In this section we'll derive the second order accurate FDTD
update equations for electric and magnetic fields.

\subsection{Yee mesh\label{sec:yee-mesh}}

In Yee mesh vertecies are located at:
\begin{align}
  \label{eq:yee-vertex-locations}
  \ve x_{m,n,l}
  = m \Delta x_0 \hat{\ve e}_0 + n \Delta x_1\hat{\ve e}_1 + l \Delta x_2 \hat{\ve e}_2
\end{align}
where $\Delta x_i$ is the grid spacing in $\hat{\ve e}_i$ direction,
$\hat{\ve e}_i$ denotes the orthogonal unit vectors and $m,n,l \in \mathbb{N}$.
Electric field components $E_i$ and electric current density componentes $J_i$
are stored at locations:
\begin{align}
  \label{eq:yee-E-locations}
  \ve x^{E_i}_{m,n,l} = \ve x_{m,n,l} + \frac{1}{2}\Delta x_i \hat{\ve e}_i =
  \begin{cases}
    \ve x_{m+\frac12, n, l} \quad & i=0\\
    \ve x_{m, n+\frac12, l} \quad & i=1 \\
    \ve x_{m, n, l+\frac12} \quad & i=2
  \end{cases}
\end{align}
and magnetic field components $B_i$ are stored at:
\begin{align}
  \label{eq:yee-B-locations}
  \ve x^{B_i}_{m,n,l} =
\ve x_{m,n,l} + \frac12 \sum_{r\in\{1, 2, 3\}/{i}}\Delta x_{i} \hat{\ve e}_{i} =
  \begin{cases}
    \ve x_{m, n+\frac12, l+\frac12} \quad & i=0\\
    \ve x_{m+\frac12, n, l+\frac12} \quad & i=1 \\
    \ve x_{m+\frac12, n+\frac12, l} \quad & i=2
  \end{cases}
\end{align}
See figure \ref{fig:yee-mesh} for schematic picture of the Yee mesh.

Most common way to solve equations Eq.~\eqref{eq:maxwell-faraday} and \eqref{eq:ampere-maxwell-law}
numerically is explicit leapfrog algorithm \cite{verboncoeur_particle_2005,langdon_plasma_1991}.
With leapfrog algorithm in addition to space staggering the fields are staggered in time.
Electric fields and current densitites are defined at times $s\Delta t$
and magnetic fields are defined at times $\left(s + \frac12\right)\Delta t$
where $s \in \mathbb{N}$ and $\Delta t$ is the lenght of a one time step.
The time staggering creates the problem for pushing particles,
because it needs them from the same point in time.
To achive this magnetic field is usually updated in two steps with time steps $\frac12\Delta t$.
Particle pushing is performed between these two updates.

Because the components of electromagnetic fields are stored at different locations
we can deduce the component solely from the location.
Thus we'll adpot following short hand notation for componetns of
$\ve E(t, \ve x)$ and $\ve B(t, \ve x)$:
\begin{align}
  \label{eq:shorthad-index-notation}
  \xi^{T}_{N,M,L} \equiv \xi\left(T\Delta t, \ve x^\xi_{N,M,L} \right)
\end{align}
where $\xi$ is either $E$ or $B$.
For example $E^{s}_{n,m,l+\frac12}
= E_2\left(s\Delta t, \ve x^{E_2}_{n,m,l}\right)$
and $B^{s+\frac12}_{n+\frac12,m,l+\frac12}
= B_1\left(\left(s+\frac12 \right)\Delta t, \ve x^{B_1}_{n,m,l}\right)$.
With this notation we can generally write the second order accurate
centered finite-difference temporal and spatial derivatives \eqref{eq:centered-fd}.
For the temporal derivative $h = \frac12 \Delta t$ and
for the spatial derivative in $\hat{\ve e}_i$ direction $h = \frac12 \Delta x_i$.
Thus we generally get that:
\begin{align}
  \label{eq:yee-temporal-derivative}
  \Delta t\partial_t\xi^{T}_{N,M,L} &\approx \xi^{T+\frac12}_{N,M,L} - \xi^{T-\frac12}_{N,M,L}\\
  \label{eq:yee-spatial-derivative}
  \begin{bmatrix}
    \Delta x_0 \partial_{x_0} \\
    \Delta x_1 \partial_{x_1} \\
    \Delta x_2 \partial_{x_2}
  \end{bmatrix}
  \xi^{T}_{N,M,L} &\approx
  \begin{bmatrix}
    \xi^{T}_{N+\frac12,M,L} - \xi^{T}_{N-\frac12,M,L} \\
    \xi^{T}_{N,M+\frac12,L} - \xi^{T}_{N,M-\frac12,L} \\
    \xi^{T}_{N,M,L+\frac12} - \xi^{T}_{N,M,L-\frac12}
  \end{bmatrix}
\end{align}
Note that in the next subsection we'll be evaluating derivatives $\partial_{\mu}\xi$
at specific locations where on the Yee mesh there might not be $\xi$ at that location.
However, we'll be using the centered finite-difference for the derivatives
and it happens that we'll only need the field components at such locations
that the components in the Yee mesh are precisely what we need.

\subsection{Finite-difference time domain}

We want now to apply the finite-difference derivatives~\eqref{eq:yee-temporal-derivative}
and~\eqref{eq:yee-spatial-derivative} to the dynamical Maxwell's equations~\eqref{eq:maxwell-faraday}
and~\eqref{eq:ampere-maxwell-law} inorder to get rules for updating the fields in time.
Forgetting the current density for a while\footnote{We can always add the current to the electric field
  as they are stored at the same location and time in the Yee mesh.}
they both are in form which at time $T\Delta t$ and point $\ve x_{N,M,L}$ can be written as:
\begin{align}
  \partial_t
  \begin{bmatrix}
    \alpha^T_{N,M,L} \\ \beta^T_{N,M,L} \\ \gamma^T_{N,M,L}
  \end{bmatrix}
  = \pm c \nabla \times
  \begin{bmatrix}
    \mu^T_{N,M,L} \\ \nu^T_{N,M,L} \\ \rho^T_{N,M,L}
  \end{bmatrix}
  = \pm c
  \begin{bmatrix}
    \partial_{x_1}\rho^T_{N,M,L} - \partial_{x_2}\nu^T_{N,M,L} \\
    \partial_{x_2}\mu^T_{N,M,L} - \partial_{x_0}\rho^T_{N,M,L} \\
    \partial_{x_0}\nu^T_{N,M,L} - \partial_{x_1}\mu^T_{N,M,L}
  \end{bmatrix}
\end{align}
Now we can apply the second order accurate central finite-difference
derivatives~\eqref{eq:yee-temporal-derivative} and~\eqref{eq:yee-spatial-derivative}
on the Yee mesh and obtain update equations:
\begin{equation}
  \label{eq:fdtd2-generic-update}
  \begin{split} 
  \begin{bmatrix}
    \alpha^{T+\frac12}_{N,M,L} \\ \beta^{T+\frac12}_{N,M,L} \\ \gamma^{T+\frac12}_{N,M,L}
  \end{bmatrix}
  & \approx
  \begin{bmatrix}
    \alpha^{T-\frac12}_{N,M,L} \\ \beta^{T-\frac12}_{N,M,L} \\ \gamma^{T-\frac12}_{N,M,L}
  \end{bmatrix} \\
  & \pm
  \begin{bmatrix}
    \hat{c}_1\left(\rho^T_{N,M+\frac12,L} - \rho^T_{N,M-\frac12,L}\right)
    - \hat{c}_2\left(\nu^T_{N,M,L+\frac12} - \nu^T_{N,M,L-\frac12}\right) \\
    \hat{c}_2\left(\mu^T_{N,M,L+\frac12} - \mu^T_{N,M,L-\frac12}\right)
    - \hat{c}_0\left(\rho^T_{N+\frac12,M,L} - \rho^T_{N-\frac12,M,L}\right) \\
    \hat{c}_0\left(\nu^T_{N+\frac12,M,L} - \nu^T_{N-\frac12,M,L}\right)
    - \hat{c}_1\left(\mu^T_{N,M+\frac12,L} - \mu^T_{N,M-\frac12,L}\right)
  \end{bmatrix}
  \end{split}
\end{equation}
where we have used the one dimensional Courant numbers for different direction
$\hat{c}_i\equiv \frac{c\Delta t}{\Delta x_i}$.

Now we can read the actual update equations for $\ve E$ and $\ve B$
from equation~\eqref{eq:fdtd2-generic-update} by evaluating its components
at specific locations in time and space.
Firstly we'll subtitute:
\begin{align}
  \begin{bmatrix}
    \alpha \\ \beta \\ \gamma
  \end{bmatrix}
  = \ve B
  \quad
  \begin{bmatrix}
    \mu \\ \nu \\ \rho
  \end{bmatrix}
  = \ve E \quad
  (T, N, M, L) =
  \begin{cases}
    (s, n, m+\frac12, l+\frac12) \quad & \text{on row 0} \\
    (s, n+\frac12, m, l+\frac12) \quad & \text{on row 1} \\
    (s, n+\frac12, m+\frac12, l) \quad & \text{on row 2}
  \end{cases}
\end{align}
and obtain:
\begin{equation}
\label{eq:fdtd2-B-update}
\begin{split}
  \begin{bmatrix}
    B^{s+\frac12}_{n,m+\frac12,l+\frac12} \\
    B^{s+\frac12}_{n+\frac12,m,l+\frac12} \\
    B^{s+\frac12}_{n+\frac12,m+\frac12,l}
  \end{bmatrix}
  & \approx
  \begin{bmatrix}
    B^{s-\frac12}_{n,m+\frac12,l+\frac12} \\
    B^{s-\frac12}_{n+\frac12,m,l+\frac12} \\
    B^{s-\frac12}_{n+\frac12,m+\frac12,l}
  \end{bmatrix}\\
  & -
  \begin{bmatrix}
    \hat{c}_{1}\left(E^{s}_{n,m+1,l+\frac12} - E^{s}_{n,m,l+\frac12}\right)
    - \hat{c}_{2}\left(E^{s}_{n,m+\frac12,l+1} - E^{s}_{n,m+\frac12,l}\right) \\
    \hat{c}_{2}\left(E^{s}_{n+\frac12,m,l+1} - E^{s}_{n+\frac12,m,l}\right)
    - \hat{c}_{0}\left(E^{s}_{n+1,m,l+\frac12} - E^{s}_{n,m,l+\frac12}\right) \\
    \hat{c}_{0}\left(E^{s}_{n+1,m+\frac12,l} - E^{s}_{n,m+\frac12,l}\right)
    - \hat{c}_{1}\left(E^{s}_{n+\frac12,m+1,l} - E^{s}_{n+\frac12,m,l}\right)
  \end{bmatrix}
\end{split}
\end{equation}
and secondly we'll substitute:
\begin{align}
  \begin{bmatrix}
    \alpha \\ \beta \\ \gamma
  \end{bmatrix}
  = \ve E
  \quad
  \begin{bmatrix}
    \mu \\ \nu \\ \rho
  \end{bmatrix}
  = \ve B \quad
  (T, N, M, L) =
  \begin{cases}
    (s+\frac12, n+\frac12, m, l) \quad & \text{on row 0} \\
    (s+\frac12, n, m+\frac12, l) \quad & \text{on row 1} \\
    (s+\frac12, n, m, l+\frac12) \quad & \text{on row 2}
  \end{cases}
\end{align}
and obtain (with the current density added back in):
\begin{equation}
\label{eq:fdtd2-E-update}
\begin{split}
  \begin{bmatrix}
    E^{s+1}_{n+\frac12,m,l} \\ E^{s+1}_{n,m+\frac12,l} \\ E^{s+1}_{n,m,l+\frac12}
  \end{bmatrix}
  & \approx
  \begin{bmatrix}
    E^{s}_{n+\frac12,m,l} \\ E^{s}_{n,m+\frac12,l} \\ E^{s}_{n,m,l+\frac12}
  \end{bmatrix}
  + 4\pi\Delta t
  \begin{bmatrix}
    J^{s}_{n+\frac12,m,l} \\ J^{s}_{n,m+\frac12,l} \\ J^{s}_{n,m,l+\frac12}
  \end{bmatrix} \\
  & +
  \begin{bmatrix}
    \hat{c}_1\left(B^{s+\frac12}_{n+\frac12,m+\frac12,l} - B^{s+\frac12}_{n+\frac12,m-\frac12,l}\right)
    - \hat{c}_2\left(B^{s+\frac12}_{n+\frac12,m,l+\frac12} - B^{s+\frac12}_{n+\frac12,m,l-\frac12}\right) \\
    \hat{c}_2\left(B^{s+\frac12}_{n,m+\frac12,l+\frac12} - B^{s+\frac12}_{n,m+\frac12,l-\frac12}\right)
    - \hat{c}_0\left(B^{s+\frac12}_{n+\frac12,m+\frac12,l} - B^{s+\frac12}_{n-\frac12,m+\frac12,l}\right) \\
    \hat{c}_0\left(B^{s+\frac12}_{n+\frac12,m,l+\frac12} - B^{s+\frac12}_{n-\frac12,m,l+\frac12}\right)
    - \hat{c}_1\left(B^{s+\frac12}_{n,m+\frac12,l+\frac12} - B^{s+\frac12}_{n,m-\frac12,l+\frac12}\right)
  \end{bmatrix}
\end{split}
\end{equation}

As already noted at the end of Yee mesh subsection \ref{sec:yee-mesh}
we note that the update equations \eqref{eq:fdtd2-B-update} and \eqref{eq:fdtd2-E-update}
do not contain any values that would not be present on a Yee mesh.


\input{chapters/yee-mesh}

\section{Field interpolator}

Before the paritcle can be pushed the electromagnetic fields on the discrete Yee mesh
have to interpolated to the continuous particle locations.
There exists different interpolation schemes with varying accuracy and computational costs.
GPU port of Runko uses linear interpolation.

The interpolation is done for the fields $\ve E$ and $\ve B$ which are located
on the Yee mesh according to~\eqref{eq:yee-E-locations} and \eqref{eq:yee-B-locations}.
The interpolation could be done directly from those locations to the particle positions.
However, it common to first compute $\ve E$ and $\ve B$
at the Yee mesh vertex locations~\eqref{eq:yee-vertex-locations},
for example via simple spatial averaging.
This make defining and implementing interpolators simpler
in addition to reducing short wavelength noise~\cite{langdon_plasma_1991}.

We can now write interpolation of a generic function $f$
defined on the grid vertecies~\eqref{eq:yee-vertex-locations}
to a arbitrary point $\ve x$:
\begin{align}
  f(\ve x) =
  \Delta V \sum_{n,m,l} f_{n,m,l} S'\left(\ve x_{n, m, l}, \ve x\right)
\end{align}
where $\Delta V = \prod_i \Delta x_i$, $f_{n,m,l} \equiv f(\ve x_{n,m,l})$ and
and $S'$ is the weighing function which is normalized such that at every position\footnote{
  This normalization is the convention used in~\cite{langdon_plasma_1991} which
  makes the grid contain the same amount of charge as the particles have:
  \begin{align}
  \int_V \rho dV \approx
  \Delta V\sum_{n,m,l}\rho_{n,m,l} =
  \Delta V\sum_{n,m,l}\sum_j q_j S'(\ve x_{n,m,l}, \ve x_j) = \sum_j q_j
  \end{align}
  where sum over $j$ is over all particles and $\ve x_j$ are the particle positions.
}:
\begin{align}
  \Delta V \sum_{n,m,l}S' \left(\ve x_{n, m, l}, \ve x\right) = 1
\end{align}
The choise of the shape function $S'$ determines the interpolation scheme.
Usually the interpolation is done independently in every direction.
In such cases:
\begin{align}
  S'(\ve X, \ve x) = S(X_0 - x_0)S(X_1 - x_1)S(X_2 - x_2)
\end{align}

B-splines are commonly used as the weighing functions $S(x)$.
Starting from zeroth order B-spline one can calculate B-splines with arbitrary high order
but usually only the lowest order splines are used.
The first four are plotted in the figure \ref{fig:spline-plot}.
Choise of the zeroth order B-spline is equivalent to just using the value from the nearest grid point
and in turn choise of the first order B-spline is eqivalent to linear interpolation.

\begin{figure}[h]
  \centering
  \includegraphics{chapters/spline.pdf}
  \caption{Zeroth, first, second and third order B-spline weighing functions $S$.
    The higher the order the smoother the B-spline is.
  }
  \label{fig:spline-plot}
\end{figure}

\section{Particle pusher}

The positions and velocities of particles are updated according to
equations~\eqref{eq:newton-lorentz-vel} and~\eqref{eq:newton-lorentz}.
This procedure is called particle pushing and different numerical methods
for doing it are called particle pushers.
Similar to the fields the particle pushers often utilize the leapfrog scheme
so the particle positions are stored at times $s\Delta t$ and velocities at
times $\left(s+\frac12\right)\Delta t$.
Applying the second order accurate centered finite-difference~\eqref{eq:centered-fd}
to the equations~\eqref{eq:newton-lorentz} and~\eqref{eq:newton-lorentz-vel}
with $h=\frac12 \Delta t$ we can solve for the update equations:
\begin{align}
  \label{eq:particle-update-pos}
  \ve x^{s+1} &= \ve x^{s} + \Delta t \ve v(\ve u^{s+\frac12}) = \\
  \label{eq:particle-update-vel}
  \ve u^{s+\frac12} &= \ve u^{s-\frac12}
                      + \Delta t\frac{q}{m}\left(\ve E^s + \bar{\ve v}^s\times\ve B^s\right)
\end{align}
where the superscripts denote the time step similar to equation~\eqref{eq:shorthad-index-notation}
and $\bar{\ve v}^s$ is a some average for coordinate velocity at time $s\Delta t$.
In order to close the system it has to be expressed as a function of the other quantaties.

There are multiple different options for calculating $\bar{\ve v}^s$
corresponding to the different particle pushers.
The common problem is that the expressions usually contain $\ve u^{s+\frac12}$
which seem to make the update equation~\eqref{eq:particle-update-vel} implicit.
However, different pushers have procedures which enable to solve~\eqref{eq:particle-update-vel}
in steps such that the methods stay explicit.

In this section we will compare properties Boris pusher (1960)~\cite{boris_relativistic_1960},
Vay's method (2008)~\cite{vay_simulation_2008} and
Higuera-Cary method (2017)~\cite{higuera_structure-preserving_2017}.
As the pusher implemented in the GPU port of Runko,
we will go through the Boris pusher in more detail.

\subsection{Properties}

We begin by listing the choises for $\bar{\ve v}^s$.
The Boris pusher uses:
\begin{align}
  \label{eq:boris-avg-vel}
  \bar{\ve v}^s_b \equiv \frac{\ve u^{s+\frac12} + \ve u^{s-\frac12}}{2\gamma^s}
\end{align}
Vay's method uses:
\begin{align}
  \bar{\ve v}^s_v \equiv
  \frac{ \ve v^{s-\frac12}  + \ve v^{s+\frac12}}{2}
\end{align}
And lastly Higuera-Cary method uses:
\begin{align}
  \bar{\ve v}^s_{hc} \equiv \ve v \left( \frac{\ve u^{s-\frac12} + \ve u^{s+\frac12}}{2} \right)
\end{align}

The choises for $\bar{\ve v}^s$ seems to be very similar but
the methods have different properties which are important for physical accuracy.
As the underlying physical system is Hamiltonian
the solutions residue on a symplectic manifold in phase space~\cite{goldstein_classical_2014}.
Symplectic integrators are those which solutions are on the symplectic manifold.
Kolmogrov-Arnold-Moser theorem provides them with guarantee
that the long term evolutions stay physically accurate\footnote{
  Defining what symplectic manifold
  and what physicaslly accurate long term evolution of Hamiltonian system
  means is outside of the scope of this theses.
}.
Unfortunately there is no known explicit sympletic integrator
for charged particle motion in arbitrary electromagnetic fields~\cite{higuera_structure-preserving_2017}.
However, integrators can be phase space volume-preserving
which prevents attractors and repellers in the integrated system.

The Boris pusher is volume-preserving while Vay's method is not.
Conversly Vay's method computes the $\ve E \times \ve B$ drift correctly while The Boris pusher does not.
Higuera-Cary method on the other hand posses both of these properties.
What is common between these is that they all conserve energy in absent of electric field
and that they are second order accurate in time.
Computationally the Boris pusher is the simplest while Vay's and Higuera-Cary methods
have similar complexity.

\subsection{Boris pusher}

We begin by inserting~\eqref{eq:boris-avg-vel} to~\eqref{eq:particle-update-vel}
while switching to a notation where we drop superscripts $s$ and change superscripts
$s+\frac12\rightarrow f$ and $s-\frac12 \rightarrow i$:
\begin{align}
  \label{eq:boris-derivation-1}
  \ve u^f - \ve u^i
  %&= \frac{q\Delta t}{m}\left(\ve E + \frac{\ve u^f + \ve u^i}{2c\gamma}\times\ve B\right) \\
  &= 2\boldsymbol{\epsilon} + \eta(\ve u^f + \ve u^i) \times \hat{\ve B}
\end{align}
where we have defined $\boldsymbol{\epsilon} = \frac{q\Delta t\ve E}{2m}$,
$\eta = \frac{q\Delta t B}{2mv\gamma}$ and the unit vector $\hat{\ve B} = \ve BB^{-1}$.
We want to find a way to evaluate~\eqref{eq:boris-derivation-1}
without using implicit methods, i.e. we want to find a way to evaluate the RHS
without actually needing $\ve u^f$.

We will define vectors $\ve u_+ = \ve u^f - \boldsymbol{\epsilon}$
and $\ve u_- = \ve u^i + \boldsymbol{\epsilon}$,
thus equation \eqref{eq:boris-derivation-1} can be written as:
\begin{align}
  \ve u_+ - \ve u_- &= \eta(\ve u_+ + \ve u_-) \times \hat{\ve B}
\end{align}
We note that the above equation does not contain any components along $\hat{\ve B}$.
Denoting vector components in the plane perpendicular to $\hat{\ve B}$ with prime
we can write:
\begin{align}
  \label{eq:boris-derivation-2}
  \ve u_+ - \ve u_- = \ve u'_+ - \ve u'_- &= \eta(\ve u'_+ + \ve u'_-) \times \hat{\ve B}
\end{align}
We can deduce that vectors $\ve u'_+ - \ve u'_-$ and $\ve u'_+ + \ve u'_-$
are perpendicular to each other
and by taking dot product of the equation with $\ve u'_+ + \ve u'_-$
we can deduce that $u'_+ = u'_-$.
Denoting angle between vectors $\ve u'_+$ and $\ve u'_-$ with $\theta$
we can draw diagram of the vectors which can be seen in the figure~\ref{fig:boris}
to which we have added helper vectors $\ve h$, $\ve L_0$, $\ve L_1$ and $\ve u'_- \times \ve b$
such that $\ve L_0$ and $\ve L_1$ are perependicular to each other,
$\ve b = b \hat{\ve B}$
and that $\ve L_0 + \ve L_1 = \ve u'_- + \ve u'_- \times \ve b$.
Using these definitions we can note that $b = \tan\frac{\theta}{2} = \frac{h}{L_1}$
and $L_0 = L_1 b^2$.


\input{chapters/boris}

We can now try to express $\ve u'_+ - \ve u'_-$
using another way than in~\eqref{eq:boris-derivation-2}.
Particularly we can write:
\begin{equation}
\begin{split}
  \ve u'_+ - \ve u'_- &= 2h \hat{\ve L}_1 \times \hat{\ve B}
  = \frac{2}{1+b^2}(\ve L_0 + \ve L_1) \times \ve b \\
  &= \frac{2}{1+b^2}(\ve u'_- + \ve u'_- \times \ve b)\times \ve b
\end{split}
\end{equation}
where $\hat{\ve L}_1$ is the unit vector along $\ve L_1$.
We can now go back to $\ve u^f$ and $\ve u^i$ to obtain the Boris pusher update equation:
\begin{equation}
\begin{split}
  \ve u^f &= \ve u^i + 2 \boldsymbol{\epsilon}
            + \frac{2}{1+b^2}(\ve u'_- + \ve u'_- \times \ve b)\times \ve b \\
          &= \ve u^i + \frac{q\Delta t \ve E}{m}
            + \frac{2}{1+b^2}\left(\ve u^i + \frac{q\Delta t \ve E}{2m}
            + \left(\ve u^i + \frac{q\Delta t \ve E}{2m}\right) \times \ve b\right)\times \ve b
\end{split}
\end{equation}
Only thing left is to determine the angle $\theta$ between $\ve u_+$ and $\ve u_-$
in order to calculate $\ve b$. To do this we use physical argument.
Namely that the angle should correspond to the gyrotation due to the magnetic field.
Thus using the cyclotrone frequency~\eqref{eq:cyclotron-frequency}:
\begin{align}
  \theta \approx \Delta t \omega_B = \frac{qB\Delta t}{mc\gamma}
\end{align}
Assuming that the time step is small:
\begin{align}
  b  = \tan\frac\theta 2 = \frac\theta 2 + O(\Delta t^3) = \frac{qB\Delta t}{2mc\gamma} + O(\Delta t^3)
\end{align}

\section{Current deposition}
\section{Current filter}


%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../gradu"
%%% End:
